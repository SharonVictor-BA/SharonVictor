# -*- coding: utf-8 -*-
"""app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18AWPCMqJpvj-38SHmHtKDX6Mh4_ZQust
"""

import streamlit as st
from datetime import date, timedelta
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split

# ------------------------------
# Page Configuration
# ------------------------------
st.set_page_config(page_title="CO2 Emission Forecasting App", page_icon="🌿", layout="wide")

# ------------------------------
# App Header
# ------------------------------
st.image(
    "https://geographical.co.uk/wp-content/uploads/carbon-dioxide-emissions-title.jpg", width=80
)
st.title("🌍 CO2 Emission Forecasting App")
st.caption("Built for Industrial Auditing Purposes")
st.markdown("""
This application enables organizations to forecast CO₂ emissions based on operational and supply chain inputs.

**Business Value:**
- Track CO₂ footprint across supply chain
- Compare forecast vs historical emissions
- Make data-driven ESG decisions
""")

# --- Load Data ---
df = pd.read_csv("CO2_Emission_Prediction_Dataset.csv")
df['Date'] = pd.to_datetime(df['Date'], format='%d-%m-%Y')
df['Year'] = df['Date'].dt.year
df['Month'] = df['Date'].dt.month

# --- Constants ---
target_vars = [
    'Total CO2 Emissions from Facility (kg)',
    'CO2 Emissions After Initiatives (kg)',
    'CO2 Emissions per km/mile (kg/km)'
]
categorical_features = ['Facility Type', 'Emission Source', 'Transport Mode', 'Material Type', 'Supply Chain Activity']
numeric_features = ['Year', 'Month']

FACILITY_TYPES = ['Manufacturing', 'Office', 'Warehouse']
EMISSION_SOURCES = ['Electricity', 'Fuel', 'Transport', 'Waste']
TRANSPORT_MODES = ['Air', 'Rail', 'Ship', 'Truck']
MATERIAL_TYPES = ['Aluminum', 'Plastic', 'Steel']
SUPPLY_CHAIN_ACTIVITIES = ['Inbound', 'Internal', 'Outbound']

# --- Sidebar Inputs ---
st.sidebar.header("📥 Forecast Parameters")
selected_facility = st.sidebar.selectbox("Facility Type", FACILITY_TYPES)
selected_emission = st.sidebar.selectbox("Emission Source", EMISSION_SOURCES)
selected_transport = st.sidebar.selectbox("Transport Mode", TRANSPORT_MODES)
selected_material = st.sidebar.selectbox("Material Type", MATERIAL_TYPES)
selected_activity = st.sidebar.selectbox("Supply Chain Activity", SUPPLY_CHAIN_ACTIVITIES)
today = date.today()
selected_pred_date = st.sidebar.date_input(
    "Prediction Date (within 1 year)",
    value=today + timedelta(days=30),
    min_value=today,
    max_value=today + timedelta(days=365)
)

# --- Initialize structures ---
grades = []
scores = []
grade_map = {'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1}
grade_color_map = {
    'A': '🟩 Excellent (A)',
    'B': '🟦 Good (B)',
    'C': '🟨 Moderate (C)',
    'D': '🟥 Poor (D)',
    'E': '🟥 Critical (E)'
}
predictions_dict = {}
min_max_dict = {}

# --- Train Models and Predict ---
X = pd.get_dummies(df[categorical_features + numeric_features])
for target in target_vars:
    y = df[target]
    model = RandomForestRegressor(n_estimators=200, random_state=42)
    model.fit(X, y)

    input_data = {
        'Facility Type_' + selected_facility: 1,
        'Emission Source_' + selected_emission: 1,
        'Transport Mode_' + selected_transport: 1,
        'Material Type_' + selected_material: 1,
        'Supply Chain Activity_' + selected_activity: 1,
        'Year': selected_pred_date.year,
        'Month': selected_pred_date.month
    }
    input_df = pd.DataFrame([input_data])
    for col in X.columns:
        if col not in input_df.columns:
            input_df[col] = 0
    input_df = input_df[X.columns]

    pred = model.predict(input_df)[0]
    predictions_dict[target] = pred
    min_val = df[target].min()
    max_val = df[target].max()
    min_max_dict[target] = (min_val, max_val)

    # Grade based on normalized range
    percentile = (pred - min_val) / (max_val - min_val) if max_val > min_val else 0
    if percentile <= 0.25:
        grade = 'A'
    elif percentile <= 0.50:
        grade = 'B'
    elif percentile <= 0.75:
        grade = 'C'
    elif percentile <= 1.00:
        grade = 'D'
    else:
        grade = 'E'

    grades.append(grade)
    scores.append(grade_map[grade])

# --- Overall Score ---
avg_score = np.mean(scores)
if avg_score >= 4.5:
    overall = 'A'
elif avg_score >= 3.5:
    overall = 'B'
elif avg_score >= 2.5:
    overall = 'C'
elif avg_score >= 1.5:
    overall = 'D'
else:
    overall = 'E'

# --- Grade Display as KPI Card ---
st.markdown(f"""
<div style="background-color:#007BFF;padding:15px;border-radius:10px;">
    <h3 style="color:white;">Overall Environmental Emission Grade: {grade_color_map[overall]}</h3>
</div>
""", unsafe_allow_html=True)

# --- Tabs ---
tab1, tab2 = st.tabs(["📈 Forecast & KPIs", "📊 Historical Comparison"])

# --- Forecast & KPIs Tab ---
with tab1:
    for target in target_vars:
        st.markdown(f"### {target}")
        st.metric(label="Predicted Value", value=f"{predictions_dict[target]:,.2f}")
        st.success(f"Min: {min_max_dict[target][0]:,.2f}")
        st.warning(f"Max: {min_max_dict[target][1]:,.2f}")
        st.markdown("---")

# --- Historical Comparison Tab ---
with tab2:
    st.subheader("Historical CO2 Emissions Comparison")
    filtered_df = df[
        (df['Facility Type'] == selected_facility) &
        (df['Emission Source'] == selected_emission) &
        (df['Transport Mode'] == selected_transport) &
        (df['Material Type'] == selected_material) &
        (df['Supply Chain Activity'] == selected_activity)
    ].sort_values('Date')

    if not filtered_df.empty:
        for target in target_vars:
            st.markdown(f"**{target}**")
            fig, ax = plt.subplots(figsize=(10, 4))
            ax.plot(filtered_df['Date'], filtered_df[target], label='Historical')
            ax.set_facecolor("none")
            fig.patch.set_alpha(0.0)
            ax.axvline(pd.to_datetime(selected_pred_date), color='orange', linestyle='--', label='Prediction Date')
            ax.set_xlabel("Date")
            ax.set_ylabel(target)
            ax.grid(True, linestyle=':', alpha=0.6)
            ax.legend()
            st.pyplot(fig)
    else:
        st.warning("No matching historical data found for selected inputs.")
